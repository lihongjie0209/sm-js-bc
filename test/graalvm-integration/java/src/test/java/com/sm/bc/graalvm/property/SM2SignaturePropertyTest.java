package com.sm.bc.graalvm.property;

import com.sm.bc.graalvm.BaseGraalVMTest;
import com.sm.bc.graalvm.utils.TestDataGenerator;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.RepeatedTest;
import org.junit.jupiter.api.Tag;

import java.nio.charset.StandardCharsets;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Property-based tests for SM2 signature algorithm.
 * These tests verify mathematical and behavioral properties of SM2 signatures
 * rather than checking against specific expected values.
 * 
 * Properties tested:
 * 1. Signature Verifiability: Any signature generated by a valid private key can be verified with the corresponding public key
 * 2. Signature Randomness: Multiple signatures of the same message with random k should be different
 * 3. Invalid Signature Rejection: Modified signatures should fail verification
 * 4. Cross-Implementation Consistency: Java and JavaScript implementations produce compatible signatures
 * 5. Signature Round-trip: sign(message, privateKey) -> verify(message, signature, publicKey) == true
 */
@Tag("property-test")
@DisplayName("SM2 Signature Property-Based Tests")
public class SM2SignaturePropertyTest extends BaseGraalVMTest {

    private static final int ITERATIONS = 10;

    /**
     * Property: A signature generated by Java can be verified by both Java and JavaScript
     */
    @RepeatedTest(ITERATIONS)
    @DisplayName("Property: Java-generated signature is verifiable by both implementations")
    void testJavaSignatureVerifiability() throws Exception {
        // Generate random key pair
        TestDataGenerator.KeyPairTestData keyPair = TestDataGenerator.randomKeyPair();
        
        // Generate random message
        byte[] message = TestDataGenerator.randomBytes(32);
        
        // Sign with Java
        String signature = signWithJavaSM2(message, keyPair.getPrivateKeyHex());
        
        // Verify with both implementations
        boolean javaVerifies = verifyWithJavaSM2(message, signature, keyPair.getPublicKeyHex());
        boolean jsVerifies = verifyWithJavaScriptSM2(message, signature, keyPair.getPublicKeyHex());
        
        assertTrue(javaVerifies, "Java should verify its own signature");
        assertTrue(jsVerifies, "JavaScript should verify Java signature");
    }

    /**
     * Property: A signature generated by JavaScript can be verified by both Java and JavaScript
     */
    @RepeatedTest(ITERATIONS)
    @DisplayName("Property: JavaScript-generated signature is verifiable by both implementations")
    void testJavaScriptSignatureVerifiability() throws Exception {
        // Generate random key pair
        TestDataGenerator.KeyPairTestData keyPair = TestDataGenerator.randomKeyPair();
        
        // Generate random message
        byte[] message = TestDataGenerator.randomBytes(32);
        
        // Sign with JavaScript
        String signature = signWithJavaScriptSM2(message, keyPair.getPrivateKeyHex());
        
        // Verify with both implementations
        boolean javaVerifies = verifyWithJavaSM2(message, signature, keyPair.getPublicKeyHex());
        boolean jsVerifies = verifyWithJavaScriptSM2(message, signature, keyPair.getPublicKeyHex());
        
        assertTrue(javaVerifies, "Java should verify JavaScript signature");
        assertTrue(jsVerifies, "JavaScript should verify its own signature");
    }

    /**
     * Property: Signatures with random k should be different for the same message and key
     * Note: This tests that the random component k is working properly
     */
    @RepeatedTest(ITERATIONS)
    @DisplayName("Property: Multiple signatures of same message are different (random k)")
    void testSignatureRandomness() throws Exception {
        // Generate key pair
        TestDataGenerator.KeyPairTestData keyPair = TestDataGenerator.randomKeyPair();
        
        // Fixed message
        byte[] message = "Test message for randomness".getBytes(StandardCharsets.UTF_8);
        
        // Generate two signatures with Java (should use random k)
        String signature1 = signWithJavaSM2(message, keyPair.getPrivateKeyHex());
        String signature2 = signWithJavaSM2(message, keyPair.getPrivateKeyHex());
        
        // Signatures should be different (because of random k)
        assertNotEquals(signature1, signature2, 
            "Two signatures of the same message should be different due to random k");
        
        // But both should verify
        assertTrue(verifyWithJavaSM2(message, signature1, keyPair.getPublicKeyHex()));
        assertTrue(verifyWithJavaSM2(message, signature2, keyPair.getPublicKeyHex()));
    }

    /**
     * Property: Modified signatures should fail verification
     */
    @RepeatedTest(ITERATIONS)
    @DisplayName("Property: Modified signatures are rejected")
    void testInvalidSignatureRejection() throws Exception {
        // Generate key pair and message
        TestDataGenerator.KeyPairTestData keyPair = TestDataGenerator.randomKeyPair();
        byte[] message = TestDataGenerator.randomBytes(32);
        
        // Generate valid signature
        String validSignature = signWithJavaSM2(message, keyPair.getPrivateKeyHex());
        
        // Modify the signature by flipping a bit in the middle
        String modifiedSignature = modifySignature(validSignature);
        
        // Valid signature should verify
        assertTrue(verifyWithJavaSM2(message, validSignature, keyPair.getPublicKeyHex()),
            "Valid signature should verify");
        
        // Modified signature should not verify
        assertFalse(verifyWithJavaSM2(message, modifiedSignature, keyPair.getPublicKeyHex()),
            "Modified signature should fail verification");
    }

    /**
     * Property: Verification fails with wrong public key
     */
    @RepeatedTest(ITERATIONS)
    @DisplayName("Property: Verification fails with wrong public key")
    void testWrongPublicKeyRejection() throws Exception {
        // Generate two different key pairs
        TestDataGenerator.KeyPairTestData keyPair1 = TestDataGenerator.randomKeyPair();
        TestDataGenerator.KeyPairTestData keyPair2 = TestDataGenerator.randomKeyPair();
        
        // Generate message and sign with first key
        byte[] message = TestDataGenerator.randomBytes(32);
        String signature = signWithJavaSM2(message, keyPair1.getPrivateKeyHex());
        
        // Should verify with correct public key
        assertTrue(verifyWithJavaSM2(message, signature, keyPair1.getPublicKeyHex()),
            "Should verify with correct public key");
        
        // Should fail with wrong public key
        assertFalse(verifyWithJavaSM2(message, signature, keyPair2.getPublicKeyHex()),
            "Should fail verification with wrong public key");
    }

    /**
     * Property: Verification fails with modified message
     */
    @RepeatedTest(ITERATIONS)
    @DisplayName("Property: Verification fails with modified message")
    void testModifiedMessageRejection() throws Exception {
        // Generate key pair
        TestDataGenerator.KeyPairTestData keyPair = TestDataGenerator.randomKeyPair();
        
        // Generate message and signature
        byte[] message = TestDataGenerator.randomBytes(32);
        String signature = signWithJavaSM2(message, keyPair.getPrivateKeyHex());
        
        // Should verify with original message
        assertTrue(verifyWithJavaSM2(message, signature, keyPair.getPublicKeyHex()),
            "Should verify with original message");
        
        // Modify message
        byte[] modifiedMessage = message.clone();
        modifiedMessage[0] ^= 0x01; // Flip one bit
        
        // Should fail with modified message
        assertFalse(verifyWithJavaSM2(modifiedMessage, signature, keyPair.getPublicKeyHex()),
            "Should fail verification with modified message");
    }

    /**
     * Property: Empty message can be signed and verified
     */
    @RepeatedTest(ITERATIONS)
    @DisplayName("Property: Empty message signature round-trip")
    void testEmptyMessageSignature() throws Exception {
        // Generate key pair
        TestDataGenerator.KeyPairTestData keyPair = TestDataGenerator.randomKeyPair();
        
        // Empty message
        byte[] emptyMessage = new byte[0];
        
        // Sign with both implementations
        String javaSignature = signWithJavaSM2(emptyMessage, keyPair.getPrivateKeyHex());
        String jsSignature = signWithJavaScriptSM2(emptyMessage, keyPair.getPrivateKeyHex());
        
        // Both should verify
        assertTrue(verifyWithJavaSM2(emptyMessage, javaSignature, keyPair.getPublicKeyHex()),
            "Java signature of empty message should verify");
        assertTrue(verifyWithJavaScriptSM2(emptyMessage, jsSignature, keyPair.getPublicKeyHex()),
            "JavaScript signature of empty message should verify");
        
        // Cross-verify
        assertTrue(verifyWithJavaScriptSM2(emptyMessage, javaSignature, keyPair.getPublicKeyHex()),
            "JavaScript should verify Java signature of empty message");
        assertTrue(verifyWithJavaSM2(emptyMessage, jsSignature, keyPair.getPublicKeyHex()),
            "Java should verify JavaScript signature of empty message");
    }

    /**
     * Property: Large message can be signed and verified
     */
    @RepeatedTest(ITERATIONS)
    @DisplayName("Property: Large message signature round-trip")
    void testLargeMessageSignature() throws Exception {
        // Generate key pair
        TestDataGenerator.KeyPairTestData keyPair = TestDataGenerator.randomKeyPair();
        
        // Large message (10KB)
        byte[] largeMessage = TestDataGenerator.randomBytes(10 * 1024);
        
        // Sign with both implementations
        String javaSignature = signWithJavaSM2(largeMessage, keyPair.getPrivateKeyHex());
        String jsSignature = signWithJavaScriptSM2(largeMessage, keyPair.getPrivateKeyHex());
        
        // Both should verify
        assertTrue(verifyWithJavaSM2(largeMessage, javaSignature, keyPair.getPublicKeyHex()),
            "Java signature of large message should verify");
        assertTrue(verifyWithJavaScriptSM2(largeMessage, jsSignature, keyPair.getPublicKeyHex()),
            "JavaScript signature of large message should verify");
        
        // Cross-verify
        assertTrue(verifyWithJavaScriptSM2(largeMessage, javaSignature, keyPair.getPublicKeyHex()),
            "JavaScript should verify Java signature of large message");
        assertTrue(verifyWithJavaSM2(largeMessage, jsSignature, keyPair.getPublicKeyHex()),
            "Java should verify JavaScript signature of large message");
    }

    /**
     * Property: Signature verification is deterministic
     * (Same signature always produces same verification result)
     */
    @RepeatedTest(ITERATIONS)
    @DisplayName("Property: Signature verification is deterministic")
    void testVerificationDeterminism() throws Exception {
        // Generate key pair and message
        TestDataGenerator.KeyPairTestData keyPair = TestDataGenerator.randomKeyPair();
        byte[] message = TestDataGenerator.randomBytes(32);
        
        // Generate signature
        String signature = signWithJavaSM2(message, keyPair.getPrivateKeyHex());
        
        // Verify multiple times - should always get the same result
        boolean result1 = verifyWithJavaSM2(message, signature, keyPair.getPublicKeyHex());
        boolean result2 = verifyWithJavaSM2(message, signature, keyPair.getPublicKeyHex());
        boolean result3 = verifyWithJavaSM2(message, signature, keyPair.getPublicKeyHex());
        
        assertEquals(result1, result2, "Verification should be deterministic");
        assertEquals(result2, result3, "Verification should be deterministic");
        assertTrue(result1, "Valid signature should verify");
    }

    /**
     * Property: Different messages produce different signatures (with high probability)
     */
    @RepeatedTest(ITERATIONS)
    @DisplayName("Property: Different messages produce different signatures")
    void testMessageUniqueness() throws Exception {
        // Generate key pair
        TestDataGenerator.KeyPairTestData keyPair = TestDataGenerator.randomKeyPair();
        
        // Generate two different messages
        byte[] message1 = TestDataGenerator.randomBytes(32);
        byte[] message2 = TestDataGenerator.randomBytes(32);
        
        // Ensure messages are different
        assertFalse(java.util.Arrays.equals(message1, message2),
            "Test setup: messages should be different");
        
        // Sign both messages
        String signature1 = signWithJavaSM2(message1, keyPair.getPrivateKeyHex());
        String signature2 = signWithJavaSM2(message2, keyPair.getPrivateKeyHex());
        
        // Signatures should be different
        assertNotEquals(signature1, signature2,
            "Signatures of different messages should be different");
        
        // Each should verify with its own message
        assertTrue(verifyWithJavaSM2(message1, signature1, keyPair.getPublicKeyHex()));
        assertTrue(verifyWithJavaSM2(message2, signature2, keyPair.getPublicKeyHex()));
        
        // Cross-verification should fail
        assertFalse(verifyWithJavaSM2(message1, signature2, keyPair.getPublicKeyHex()),
            "Signature for message2 should not verify message1");
        assertFalse(verifyWithJavaSM2(message2, signature1, keyPair.getPublicKeyHex()),
            "Signature for message1 should not verify message2");
    }

    /**
     * Helper method to modify a signature by flipping bits
     */
    private String modifySignature(String signature) {
        // Convert to char array and flip a bit in the middle
        char[] chars = signature.toCharArray();
        int midpoint = chars.length / 2;
        
        // Flip the character at midpoint (change one hex digit)
        char c = chars[midpoint];
        if (c >= '0' && c <= '9') {
            chars[midpoint] = (char)((c - '0' + 1) % 10 + '0');
        } else if (c >= 'a' && c <= 'f') {
            chars[midpoint] = (char)((c - 'a' + 1) % 6 + 'a');
        } else if (c >= 'A' && c <= 'F') {
            chars[midpoint] = (char)((c - 'A' + 1) % 6 + 'A');
        }
        
        return new String(chars);
    }
}
