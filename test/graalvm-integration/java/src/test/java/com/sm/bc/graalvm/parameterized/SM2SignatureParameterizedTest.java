package com.sm.bc.graalvm.parameterized;

import com.sm.bc.graalvm.BaseGraalVMTest;
import com.sm.bc.graalvm.utils.TestDataGenerator;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.MethodSource;
import org.junit.jupiter.params.provider.ValueSource;

import java.nio.charset.StandardCharsets;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Parameterized tests for SM2 signature cross-language consistency.
 * These tests verify that Java and JavaScript implementations produce
 * compatible signatures that can be verified by both implementations.
 * <p>
 * Note: We don't compare signature values directly because SM2 signatures
 * include randomness (k parameter). Instead, we verify that signatures
 * generated by one implementation can be verified by the other.
 * <p>
 * Key pairs are dynamically generated for each test run to ensure robustness.
 */
@DisplayName("SM2 Signature Parameterized Tests")
public class SM2SignatureParameterizedTest extends BaseGraalVMTest {

    private TestDataGenerator.KeyPairTestData testKeyPair;

    @BeforeEach
    void generateTestKeyPair() {
        // Generate a fresh key pair for each test
        testKeyPair = TestDataGenerator.randomKeyPair();
    }

    /**
     * Test data class for key pairs
     */
    static class KeyPairTestData {
        final String privateKey;
        final String publicKey;
        final String description;

        KeyPairTestData(String privateKey, String publicKey, String description) {
            this.privateKey = privateKey;
            this.publicKey = publicKey;
            this.description = description;
        }

        @Override
        public String toString() {
            return description;
        }
    }

    /**
     * Provide test key pairs
     */
    static Stream<KeyPairTestData> provideKeyPairs() {
        return Stream.of(
                // Test key pair 1 - Generated by SM2.generateKeyPair()
                new KeyPairTestData(
                        "8906C0D7DED4D00264DABBB49301C80386C3AB15ABF90B813DCEC7B564910821",
                        "04187046D9402A70F8B4A6AAB5F9C64E6B36FED6CEDB3177BA815DA7049FB0E01F67DF7273410A81219AF8D8C5BA28A9DE0DCCA0589998EC13619A6E9E63906F7A",
                        "Generated key pair 1"
                ),
                // Test key pair 2 - Generated by SM2.generateKeyPair()
                new KeyPairTestData(
                        "4762E7E8D6B0B3CD41A3F2BA93CAA19630574D21355A05B43C45E7008DE19EFC",
                        "04C847573A30BA1A5B1E2E1BB52CE7E68AF0F4092A0888BD816657EE6B7DC463D0BA971056E7CAB3E5159347558BCFA5BC075B01AB95AE49EDE28AC70CF7253B3A",
                        "Generated key pair 2"
                ),
                // Test key pair 3 - Generated by SM2.generateKeyPair()
                new KeyPairTestData(
                        "7595A2569E5E3AB8530B2C0D9CDF4DDFB9EED9E6785CE2F25B5807022B6E081A",
                        "0493DEEC5F2F57F3F9D0927309A40B1E3F33352DA520384C9CA67FC6CC216897214A95446D5F8BED3C9ED5241D8CF580EB837B29AABF78304FCFADB396B783A062",
                        "Generated key pair 3"
                )
        );
    }

    /**
     * Test signing and verification with different messages using the same key pair.
     * Verifies that both implementations can sign and verify each other's signatures.
     */
    @ParameterizedTest(name = "[{index}] {0}")
    @ValueSource(strings = {
            "",
            "a",
            "abc",
            "message digest",
            "The quick brown fox jumps over the lazy dog",
            "SM2Êï∞Â≠óÁ≠æÂêçÁÆóÊ≥ïÊµãËØï",
            "üîê Secure Signature Test üîè",
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
    })
    @DisplayName("Sign and verify with different messages")
    void testSignAndVerifyWithDifferentMessages(String message) throws Exception {
        // Use dynamically generated key pair
        String privateKey = testKeyPair.getPrivateKeyHex();
        String publicKey = testKeyPair.getPublicKeyHex();
        
        byte[] messageBytes = message.getBytes(StandardCharsets.UTF_8);

        System.out.println("Testing message: \"" + message + "\"");

        // Test Java sign -> Java verify
        String javaSignature = signWithJavaSM2(messageBytes, privateKey);
        boolean javaVerifyResult = verifyWithJavaSM2(messageBytes, javaSignature, publicKey);
        assertTrue(javaVerifyResult, "Java should verify its own signature");
        System.out.println("  ‚úì Java sign -> Java verify: OK");

        // Test JavaScript sign -> JavaScript verify
        String jsSignature = signWithJavaScriptSM2(messageBytes, privateKey);
        boolean jsVerifyResult = verifyWithJavaScriptSM2(messageBytes, jsSignature, publicKey);
        assertTrue(jsVerifyResult, "JavaScript should verify its own signature");
        System.out.println("  ‚úì JavaScript sign -> JavaScript verify: OK");

        // Test cross-verification: Java sign -> JavaScript verify
        boolean javaToJsVerifyResult = verifyWithJavaScriptSM2(messageBytes, javaSignature, publicKey);
        assertTrue(javaToJsVerifyResult, "JavaScript should verify Java signature");
        System.out.println("  ‚úì Java sign -> JavaScript verify: OK");

        // Test cross-verification: JavaScript sign -> Java verify
        boolean jsToJavaVerifyResult = verifyWithJavaSM2(messageBytes, jsSignature, publicKey);
        assertTrue(jsToJavaVerifyResult, "Java should verify JavaScript signature");
        System.out.println("  ‚úì JavaScript sign -> Java verify: OK");
        
        System.out.println("  ‚úì Cross-language signature compatibility confirmed");
    }

    /**
     * Test signing with different key pairs using the same message.
     * Verifies that different key pairs produce different signatures.
     */
    @ParameterizedTest
    @MethodSource("provideKeyPairs")
    @DisplayName("Sign and verify with different key pairs")
    void testSignAndVerifyWithDifferentKeyPairs(KeyPairTestData keyPair) throws Exception {
        String message = "Test message for different key pairs";
        byte[] messageBytes = message.getBytes(StandardCharsets.UTF_8);

        System.out.println("Testing key pair: " + keyPair.description);

        // Test Java implementation
        String javaSignature = signWithJavaSM2(messageBytes, keyPair.privateKey);
        boolean javaVerifyResult = verifyWithJavaSM2(messageBytes, javaSignature, keyPair.publicKey);
        assertTrue(javaVerifyResult, "Java should verify signature for: " + keyPair.description);
        System.out.println("  ‚úì Java sign and verify: OK");

        // Test JavaScript implementation
        String jsSignature = signWithJavaScriptSM2(messageBytes, keyPair.privateKey);
        boolean jsVerifyResult = verifyWithJavaScriptSM2(messageBytes, jsSignature, keyPair.publicKey);
        assertTrue(jsVerifyResult, "JavaScript should verify signature for: " + keyPair.description);
        System.out.println("  ‚úì JavaScript sign and verify: OK");

        // Test cross-verification
        boolean javaToJsVerifyResult = verifyWithJavaScriptSM2(messageBytes, javaSignature, keyPair.publicKey);
        assertTrue(javaToJsVerifyResult, "JavaScript should verify Java signature for: " + keyPair.description);
        System.out.println("  ‚úì Java sign -> JavaScript verify: OK");

        boolean jsToJavaVerifyResult = verifyWithJavaSM2(messageBytes, jsSignature, keyPair.publicKey);
        assertTrue(jsToJavaVerifyResult, "Java should verify JavaScript signature for: " + keyPair.description);
        System.out.println("  ‚úì JavaScript sign -> Java verify: OK");
    }

    /**
     * Test signature verification fails with wrong public key.
     */
    @ParameterizedTest(name = "[{index}] {0}")
    @ValueSource(strings = {
            "Test message 1",
            "Test message 2"
    })
    @DisplayName("Verify signature fails with wrong public key")
    void testVerificationFailsWithWrongKey(String message) throws Exception {
        byte[] messageBytes = message.getBytes(StandardCharsets.UTF_8);
        
        // Use testKeyPair for signing
        String privateKey = testKeyPair.getPrivateKeyHex();
        String correctPublicKey = testKeyPair.getPublicKeyHex();
        
        // Generate a different key pair for wrong key test
        TestDataGenerator.KeyPairTestData wrongKeyPair = TestDataGenerator.randomKeyPair();
        String wrongPublicKey = wrongKeyPair.getPublicKeyHex();

        System.out.println("Testing message: \"" + message + "\"");

        // Sign with Java
        String javaSignature = signWithJavaSM2(messageBytes, privateKey);
        
        // Verify with wrong key should fail
        boolean javaWrongKeyResult = verifyWithJavaSM2(messageBytes, javaSignature, wrongPublicKey);
        assertFalse(javaWrongKeyResult, "Java verification should fail with wrong public key");
        System.out.println("  ‚úì Java: Verification correctly fails with wrong key");

        // Sign with JavaScript
        String jsSignature = signWithJavaScriptSM2(messageBytes, privateKey);
        
        // Verify with wrong key should fail
        boolean jsWrongKeyResult = verifyWithJavaScriptSM2(messageBytes, jsSignature, wrongPublicKey);
        assertFalse(jsWrongKeyResult, "JavaScript verification should fail with wrong public key");
        System.out.println("  ‚úì JavaScript: Verification correctly fails with wrong key");
    }

    /**
     * Test signature verification fails with modified message.
     */
    @ParameterizedTest(name = "[{index}] {0}")
    @ValueSource(strings = {
            "Original message",
            "Another test message",
            "Êï∞Â≠óÁ≠æÂêçÂÆåÊï¥ÊÄßÊµãËØï"
    })
    @DisplayName("Verify signature fails with modified message")
    void testVerificationFailsWithModifiedMessage(String originalMessage) throws Exception {
        String privateKey = testKeyPair.getPrivateKeyHex();
        String publicKey = testKeyPair.getPublicKeyHex();
        
        byte[] originalBytes = originalMessage.getBytes(StandardCharsets.UTF_8);
        byte[] modifiedBytes = (originalMessage + " modified").getBytes(StandardCharsets.UTF_8);

        System.out.println("Testing message integrity: \"" + originalMessage + "\"");

        // Sign original message with Java
        String javaSignature = signWithJavaSM2(originalBytes, privateKey);
        
        // Verify with modified message should fail
        boolean javaModifiedResult = verifyWithJavaSM2(modifiedBytes, javaSignature, publicKey);
        assertFalse(javaModifiedResult, "Java verification should fail with modified message");
        System.out.println("  ‚úì Java: Verification correctly fails with modified message");

        // Sign original message with JavaScript
        String jsSignature = signWithJavaScriptSM2(originalBytes, privateKey);
        
        // Verify with modified message should fail
        boolean jsModifiedResult = verifyWithJavaScriptSM2(modifiedBytes, jsSignature, publicKey);
        assertFalse(jsModifiedResult, "JavaScript verification should fail with modified message");
        System.out.println("  ‚úì JavaScript: Verification correctly fails with modified message");
    }

    /**
     * Test signing messages of various lengths.
     */
    @ParameterizedTest(name = "[{index}] Message length: {0} bytes")
    @ValueSource(ints = {0, 1, 16, 32, 64, 128, 256, 512, 1024})
    @DisplayName("Sign and verify messages of various lengths")
    void testSignAndVerifyVariousMessageLengths(int length) throws Exception {
        String privateKey = testKeyPair.getPrivateKeyHex();
        String publicKey = testKeyPair.getPublicKeyHex();
        
        // Generate message of specified length
        byte[] message = new byte[length];
        for (int i = 0; i < length; i++) {
            message[i] = (byte) (i % 256);
        }

        System.out.println("Testing message length: " + length + " bytes");

        // Test Java sign -> cross-language verify
        String javaSignature = signWithJavaSM2(message, privateKey);
        boolean javaVerifyResult = verifyWithJavaSM2(message, javaSignature, publicKey);
        assertTrue(javaVerifyResult, "Java should verify its own signature for " + length + " bytes");
        
        boolean jsVerifyJavaResult = verifyWithJavaScriptSM2(message, javaSignature, publicKey);
        assertTrue(jsVerifyJavaResult, "JavaScript should verify Java signature for " + length + " bytes");
        System.out.println("  ‚úì Java sign -> both verify: OK");

        // Test JavaScript sign -> cross-language verify
        String jsSignature = signWithJavaScriptSM2(message, privateKey);
        boolean jsVerifyResult = verifyWithJavaScriptSM2(message, jsSignature, publicKey);
        assertTrue(jsVerifyResult, "JavaScript should verify its own signature for " + length + " bytes");
        
        boolean javaVerifyJsResult = verifyWithJavaSM2(message, jsSignature, publicKey);
        assertTrue(javaVerifyJsResult, "Java should verify JavaScript signature for " + length + " bytes");
        System.out.println("  ‚úì JavaScript sign -> both verify: OK");
    }
}
